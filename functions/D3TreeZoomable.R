D3TreeZoomable <- function( path_to_json_data_file, 
				            outputFileName, 
				            vertical_distance = 40,
            				horizontal_distance = 6,
			            	circle_radius = 4.5,
            				circle_stroke_width = 1, 
			            	circle_stroke_color = "red",
            				ghostCircle_radius = 30,
			            	ghostCircle_opacity = 0.2,
            				ghostCircle_fill_color = "#EEB4B4",
			            	fill_color_childfree = "#FFF",
            				fill_color_child = "#EEB4B4", 
			            	font_size = "0.78em",
            				font_family = "sans-serif",
            				font_weight = 500,
			            	font_color = "black",
            				font_color_mouseover = "red",
			            	link_width = "1px",
            				link_color = "#bcbcbc", 
			            	background_color = "#FFF" )
{
    jsondata <- readLines(path_to_json_data_file)
	CSSHeadTop <- "<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style> \n.node {\n  cursor: pointer;\n}\n"
    bgCSS      <- paste( ".overlay{\n  background-color:", background_color, ";\n}\n", sep = "" )
    textCSS    <- paste( ".node text {\n  font-size: ", font_size, ";\n", "font-family: ", font_family, ";\n  font-weight: ", font_weight, ";}\n\n", sep = "") 
	linkCSS    <- paste( ".link {\n  fill: none;\n  stroke:", link_color, ";\n  stroke-width:", link_width, ";\n}\n", sep = "")
    CSSHeadBottom <- "\n.templink {\n  fill: none;\n  stroke: red;\n  stroke-width: 3px;\n}\n  .ghostCircle.show{\n  display:block;\n}\n  .ghostCircle, .activeDrag .ghostCircle{\n  display: none;\n}\n</style>"
    scripts <- "<script src=\"http://code.jquery.com/jquery-1.10.2.min.js\"></script>\n<script src=\"http://d3js.org/d3.v3.min.js\"></script>\n"
    heads <- "<head>\n</head>\n"

    bodyTop <- "<body>\n  <div id=\"tree-container\"></div>\n  <script>\n"
    treeData <- paste( "var treeData = ", jsondata, ";\n", sep = "")
    js1 <-  "// Calculate total nodes, max label length\n    var totalNodes = 0;\n    var maxLabelLength = 0;\n    // variables for drag/drop\n    var selectedNode = null;\n    var draggingNode = null;\n    // panning variables\n    var panSpeed = 200;\n    var panBoundary = 20; // Within 20px from edges will pan when dragging.\n    // Misc. variables\n    var i = 0;\n    var duration = 750;\n    var root;\n\n    // size of the diagram\n    var viewerWidth = $(document).width();\n    var viewerHeight = $(document).height();\n\n    var tree = d3.layout.tree()\n        .size([viewerHeight, viewerWidth]);\n\n    // define a d3 diagonal projection for use by the node paths later on.\n    var diagonal = d3.svg.diagonal()\n        .projection(function(d) {\n            return [d.y, d.x];\n        });\n\n    // A recursive helper function for performing some setup by walking through all nodes\n\n    function visit(parent, visitFn, childrenFn) {\n        if (!parent) return;\n\n        visitFn(parent);\n\n        var children = childrenFn(parent);\n        if (children) {\n            var count = children.length;\n            for (var i = 0; i < count; i++) {\n                visit(children[i], visitFn, childrenFn);\n            }\n        }\n    }\n\n    // Call visit function to establish maxLabelLength\n    visit(treeData, function(d) {\n        totalNodes++;\n        maxLabelLength = Math.max(d.name.length, maxLabelLength);\n\n    }, function(d) {\n        return d.children && d.children.length > 0 ? d.children : null;\n    });\n\n\n    // sort the tree according to the node names\n\n    function sortTree() {\n        tree.sort(function(a, b) {\n            return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;\n        });\n    }\n    // Sort the tree initially incase the JSON isn't in a sorted order.\n    sortTree();\n    function pan(domNode, direction) {\n        var speed = panSpeed;\n        if (panTimer) {\n            clearTimeout(panTimer);\n            translateCoords = d3.transform(svgGroup.attr(\"transform\"));\n            if (direction == 'left' || direction == 'right') {\n                translateX = direction == 'left' ? translateCoords.translate[0] + speed : translateCoords.translate[0] - speed;\n                translateY = translateCoords.translate[1];\n            } else if (direction == 'up' || direction == 'down') {\n                translateX = translateCoords.translate[0];\n                translateY = direction == 'up' ? translateCoords.translate[1] + speed : translateCoords.translate[1] - speed;\n            }\n            scaleX = translateCoords.scale[0];\n            scaleY = translateCoords.scale[1];\n            scale = zoomListener.scale();\n            svgGroup.transition().attr(\"transform\", \"translate(\" + translateX + \",\" + translateY + \")scale(\" + scale + \")\");\n            d3.select(domNode).select('g.node').attr(\"transform\", \"translate(\" + translateX + \",\" + translateY + \")\");\n            zoomListener.scale(zoomListener.scale());\n            zoomListener.translate([translateX, translateY]);\n            panTimer = setTimeout(function() {\n                pan(domNode, speed, direction);\n            }, 50);\n        }\n    }\n\n    // Define the zoom function for the zoomable tree\n\n    function zoom() {\n        svgGroup.attr(\"transform\", \"translate(\" + d3.event.translate + \")scale(\" + d3.event.scale + \")\");\n    }\n    // define the zoomListener which calls the zoom function on the \"zoom\" event constrained within the scaleExtents\n    var zoomListener = d3.behavior.zoom().scaleExtent([0.1, 3]).on(\"zoom\", zoom);\n\n    function initiateDrag(d, domNode) {\n        draggingNode = d;\n        d3.select(domNode).select('.ghostCircle').attr('pointer-events', 'none');\n        d3.selectAll('.ghostCircle').attr('class', 'ghostCircle show');\n        d3.select(domNode).attr('class', 'node activeDrag');\n\n        svgGroup.selectAll(\"g.node\").sort(function(a, b) { // select the parent and sort the path's\n            if (a.id != draggingNode.id) return 1; // a is not the hovered element, send \"a\" to the back\n            else return -1; // a is the hovered element, bring \"a\" to the front\n        });\n        // if nodes has children, remove the links and nodes\n        if (nodes.length > 1) {\n            // remove link paths\n            links = tree.links(nodes);\n            nodePaths = svgGroup.selectAll(\"path.link\")\n                .data(links, function(d) {\n                    return d.target.id;\n                }).remove();\n            // remove child nodes\n            nodesExit = svgGroup.selectAll(\"g.node\")\n                .data(nodes, function(d) {\n                    return d.id;\n                }).filter(function(d, i) {\n                    if (d.id == draggingNode.id) {\n                        return false;\n                    }\n                    return true;\n                }).remove();\n        }\n\n        // remove parent link\n        parentLink = tree.links(tree.nodes(draggingNode.parent));\n        svgGroup.selectAll('path.link').filter(function(d, i) {\n            if (d.target.id == draggingNode.id) {\n                return true;\n            }\n            return false;\n        }).remove();\n\n        dragStarted = null;\n    }\n\n    // define the baseSvg, attaching a class for styling and the zoomListener\n    var baseSvg = d3.select(\"#tree-container\").append(\"svg\")\n        .attr(\"width\", viewerWidth)\n        .attr(\"height\", viewerHeight)\n        .attr(\"class\", \"overlay\")\n        .call(zoomListener);\n    // Define the drag listeners for drag/drop behaviour of nodes.\n    dragListener = d3.behavior.drag()\n        .on(\"dragstart\", function(d) {\n            if (d == root) {\n                return;\n            }\n            dragStarted = true;\n            nodes = tree.nodes(d);\n            d3.event.sourceEvent.stopPropagation();\n            // it's important that we suppress the mouseover event on the node being dragged. Otherwise it will absorb the mouseover event and the underlying node will not detect it d3.select(this).attr('pointer-events', 'none');\n        })\n        .on(\"drag\", function(d) {\n            if (d == root) {\n                return;\n            }\n            if (dragStarted) {\n                domNode = this;\n                initiateDrag(d, domNode);\n            }\n\n            // get coords of mouseEvent relative to svg container to allow for panning\n            relCoords = d3.mouse($('svg').get(0));\n            if (relCoords[0] < panBoundary) {\n                panTimer = true;\n                pan(this, 'left');\n            } else if (relCoords[0] > ($('svg').width() - panBoundary)) {\n\n                panTimer = true;\n                pan(this, 'right');\n            } else if (relCoords[1] < panBoundary) {\n                panTimer = true;\n                pan(this, 'up');\n            } else if (relCoords[1] > ($('svg').height() - panBoundary)) {\n                panTimer = true;\n                pan(this, 'down');\n            } else {\n                try {\n                    clearTimeout(panTimer);\n                } catch (e) {\n\n                }\n            }\n\n            d.x0 += d3.event.dy;\n            d.y0 += d3.event.dx;\n            var node = d3.select(this);\n            node.attr(\"transform\", \"translate(\" + d.y0 + \",\" + d.x0 + \")\");\n            updateTempConnector();\n        }).on(\"dragend\", function(d) {\n            if (d == root) {\n                return;\n            }\n            domNode = this;\n            if (selectedNode) {\n                // now remove the element from the parent, and insert it into the new elements children\n                var index = draggingNode.parent.children.indexOf(draggingNode);\n                if (index > -1) {\n                    draggingNode.parent.children.splice(index, 1);\n                }\n                if (typeof selectedNode.children !== 'undefined' || typeof selectedNode._children !== 'undefined') {\n                    if (typeof selectedNode.children !== 'undefined') {\n                        selectedNode.children.push(draggingNode);\n                    } else {\n                        selectedNode._children.push(draggingNode);\n                    }\n                } else {\n                    selectedNode.children = [];\n                    selectedNode.children.push(draggingNode);\n                }\n                // Make sure that the node being added to is expanded so user can see added node is correctly moved\n                expand(selectedNode);\n                sortTree();\n                endDrag();\n            } else {\n                endDrag();\n            }\n        });\n\n    function endDrag() {\n        selectedNode = null;\n        d3.selectAll('.ghostCircle').attr('class', 'ghostCircle');\n        d3.select(domNode).attr('class', 'node');\n        // now restore the mouseover event or we won't be able to drag a 2nd time\n        d3.select(domNode).select('.ghostCircle').attr('pointer-events', '');\n        updateTempConnector();\n        if (draggingNode !== null) {\n            update(root);\n            centerNode(draggingNode);\n            draggingNode = null;\n        }\n    }\n\n    // Helper functions for collapsing and expanding nodes.\n\n    function collapse(d) {\n        if (d.children) {\n            d._children = d.children;\n            d._children.forEach(collapse);\n            d.children = null;\n        }\n    }\n\n    function expand(d) {\n        if (d._children) {\n            d.children = d._children;\n            d.children.forEach(expand);\n            d._children = null;\n        }\n    }\n\n    var overCircle = function(d) {\n        selectedNode = d;\n        updateTempConnector();\n    };\n    var outCircle = function(d) {\n        selectedNode = null;\n        updateTempConnector();\n    };\n\n    // Function to update the temporary connector indicating dragging affiliation\n    var updateTempConnector = function() {\n        var data = [];\n        if (draggingNode !== null && selectedNode !== null) {\n            // have to flip the source coordinates since we did this for the existing connectors on the original tree\n            data = [{\n                source: {\n                    x: selectedNode.y0,\n                    y: selectedNode.x0\n                },\n                target: {\n                    x: draggingNode.y0,\n                    y: draggingNode.x0\n                }\n            }];\n        }\n        var link = svgGroup.selectAll(\".templink\").data(data);\n\n        link.enter().append(\"path\")\n            .attr(\"class\", \"templink\")\n            .attr(\"d\", d3.svg.diagonal())\n            .attr('pointer-events', 'none');\n\n        link.attr(\"d\", d3.svg.diagonal());\n\n        link.exit().remove();\n    };\n\n    // Function to center node when clicked/dropped so node doesn't get lost when collapsing/moving with large amount of children.\n\n    function centerNode(source) {\n        scale = zoomListener.scale();\n        x = -source.y0;\n        y = -source.x0;\n        x = x * scale + viewerWidth / 2;\n        y = y * scale + viewerHeight / 2;\n        d3.select('g').transition()\n            .duration(duration)\n            .attr(\"transform\", \"translate(\" + x + \",\" + y + \")scale(\" + scale + \")\");\n        zoomListener.scale(scale);\n        zoomListener.translate([x, y]);\n    }\n\n    // Toggle children function\n\n    function toggleChildren(d) {\n        if (d.children) {\n            d._children = d.children;\n            d.children = null;\n        } else if (d._children) {\n            d.children = d._children;\n            d._children = null;\n        }\n        return d;\n    }\n\n    // Toggle children on click.\n\n    function click(d) {\n        if (d3.event.defaultPrevented) return; // click suppressed\n        d = toggleChildren(d);\n        update(d);\n        centerNode(d);\n    }"

    js2_1 <- "    function update(source) {\n        // Compute the new height, function counts total children of root node and sets tree height accordingly.\n        // This prevents the layout looking squashed when new nodes are made visible or looking sparse when nodes are removed\n        // This makes the layout more consistent.\n        var levelWidth = [1];\n        var childCount = function(level, n) {\n\n            if (n.children && n.children.length > 0) {\n                if (levelWidth.length <= level + 1) levelWidth.push(0);\n\n                levelWidth[level + 1] += n.children.length;\n                n.children.forEach(function(d) {\n                    childCount(level + 1, d);\n                });\n            }\n        };"

    js2_2 <- paste( "        childCount(0, root);\n        var newHeight = d3.max(levelWidth) * ",
                    vertical_distance, 
                    ";\n        tree = tree.size([newHeight, viewerWidth]);\n\n        // Compute the new tree layout.\n        var nodes = tree.nodes(root).reverse(),\n            links = tree.links(nodes);\n\n        // Set widths between levels based on maxLabelLength.\n        nodes.forEach(function(d) {\n            d.y = (d.depth * (maxLabelLength * ",
                    horizontal_distance, 
                    ")); //maxLabelLength * 10px\n            // alternatively to keep a fixed scale one can set a fixed depth per level\n            // Normalize for fixed-depth by commenting out below line\n            // d.y = (d.depth * 500); //500px per level.\n        });\n\n        // Update the nodes…\n        node = svgGroup.selectAll(\"g.node\")\n            .data(nodes, function(d) {\n                return d.id || (d.id = ++i);\n            });\n\n        // Enter any new nodes at the parent's previous position.\n        var nodeEnter = node.enter().append(\"g\")\n            .call(dragListener)\n            .attr(\"class\", \"node\")\n            .attr(\"transform\", function(d) {\n                return \"translate(\" + source.y0 + \",\" + source.x0 + \")\";\n            })\n            .on('click', click);\n\n        nodeEnter.append(\"circle\")\n            .attr('class', 'nodeCircle')\n            .attr(\"r\", ",
					circle_radius,
					")\n            .style(\"stroke-width\", \"",
					circle_stroke_width,
					"\")\n            .style(\"stroke\", \"",
					circle_stroke_color, 
					"\")\n            .style(\"fill\", function(d) {\n                return d._children ? \"",
					fill_color_child, 
					"\" : \"",
					fill_color_childfree,
					"\";\n            });        \n\n        // phantom node to give us mouseover in a radius around it\n        nodeEnter.append(\"circle\")\n            .attr(\"class\", \"ghostCircle\")\n            .attr(\"r\",",
					ghostCircle_radius,
					")\n            .attr(\"opacity\", ",
					ghostCircle_opacity, 
					") // change this to zero to hide the target area\n            .style(\"fill\", \"",
					ghostCircle_fill_color, "\")\n            .attr(\"pointer-events\", \"mouseover\")\n            .on(\"mouseover\", function(node) {\n                overCircle(node);\n            })\n            .on(\"mouseout\", function(node) {\n                outCircle(node);\n            });", 
					sep = "")
    js2_3 <- paste( "  var textGroup = nodeEnter.append( \"g\" );\n  var rects = textGroup.append( \"rect\" );\n  var texts = textGroup.append( \"text\" )\n                       .text( function( d ) { return d.name; } )\n                       .on( \"mouseover\", function( d ){\n                            d3.select( this )\n                            .transition( )\n                            .duration( 100 )\n                            .attr( \"fill\", \"",
    	            font_color_mouseover, 
    	            "\" );\n                       })\n                       .on( \"mouseout\", function( d ){\n                          d3.select( this )\n                            .transition( )\n                            .duration( 100 )\n                            .attr( \"fill\", \"",
    	            font_color,
    	            "\"  );\n                        })\n                       .each( function( d ) { d.width = this.getBBox( ).width; } )\n                       .attr( \"text-anchor\", function( d ) { return d.children || d._children ? \"end\" : \"start\"; })\n                       .attr( \"x\", function( d ) { return d.children || d._children ? -10 : 10; })\n                       .attr( \"dy\", \"0.30em\" )\n                       .style( \"fill-opacity\", 1e-6 );\n\n",
    	            sep = "" )
    js2_4 <- paste(  " rects.attr( \"x\" , function( d ) { return d.children || d._children ? -10 - d.width: 10; })\n       .attr( \"y\", \"-0.5em\" )\n       .attr( \"height\" , \"1em\" )\n       .style( \"fill\", \"", 
                     background_color = "#FFF", 
                     "\")\n       .style( \"fill-opacity\", 1e-6  )\n       .attr( \"width\" , function( d ) { return d.width; });\n\n\n        // Update the text to reflect whether node has children or not.\n        node.select(\"text\")\n            .attr(\"x\", function(d) {\n                return d.children || d._children ? -10 : 10;\n            })\n            .attr(\"text-anchor\", function(d) {\n                return d.children || d._children ? \"end\" : \"start\";\n            })\n            .text(function(d) {\n                return d.name;\n            });\n\n        // Change the circle fill depending on whether it has children and is collapsed\n        node.select(\"circle.nodeCircle\")\n            .attr(\"r\", ",            
                     circle_radius,
                     ")\n            .style(\"fill\", function(d) {\n                return d._children ? \"",
                     fill_color_child,
                     "\" : \"",
                     fill_color_childfree,
                     "\";\n            });\n\n",
					 sep = "")
    js2_5 <- "\n        // Transition nodes to their new position.\n        var nodeUpdate = node.transition()\n            .duration(duration)\n            .attr(\"transform\", function(d) {\n                return \"translate(\" + d.y + \",\" + d.x + \")\";\n            });\n\n        // Fade the text in\n        nodeUpdate.select(\"text\")\n            .style(\"fill-opacity\", 1);\n        nodeUpdate.select(\"rect\")\n            .style(\"fill-opacity\", 0.7);\n\n        // Transition exiting nodes to the parent\"s new position.\n        var nodeExit = node.exit().transition()\n            .duration(duration)\n            .attr(\"transform\", function(d) {\n                return \"translate(\" + source.y + \",\" + source.x + \")\";\n            })\n            .remove();\n\n        nodeExit.select(\"circle\")\n            .attr(\"r\", 0);\n\n        nodeExit.select(\"text\")\n            .style(\"fill-opacity\", 0);\n        nodeExit.select(\"rect\")\n            .style(\"fill-opacity\", 0);\n\n        // Update the links…\n        var link = svgGroup.selectAll(\"path.link\")\n            .data(links, function(d) {\n                return d.target.id;\n            });\n\n        // Enter any new links at the parent\"s previous position.\n        link.enter().insert(\"path\", \"g\")\n            .attr(\"class\", \"link\")\n            .attr(\"d\", function(d) {\n                var o = {\n                    x: source.x0,\n                    y: source.y0\n                };\n                return diagonal({\n                    source: o,\n                    target: o\n                });\n            });\n\n        // Transition links to their new position.\n        link.transition()\n            .duration(duration)\n            .attr(\"d\", diagonal);\n\n        // Transition exiting nodes to the parent\"s new position.\n        link.exit().transition()\n            .duration(duration)\n            .attr(\"d\", function(d) {\n                var o = {\n                    x: source.x,\n                    y: source.y\n                };\n                return diagonal({\n                    source: o,\n                    target: o\n                });\n            })\n            .remove();\n\n        // Stash the old positions for transition.\n        nodes.forEach(function(d) {\n            d.x0 = d.x;\n            d.y0 = d.y;\n        });\n    }\n\n    // Append a group which holds all nodes and which the zoom Listener can act upon.\n    var svgGroup = baseSvg.append(\"g\");\n\n    // Define the root\n    root = treeData;\n    root.x0 = viewerHeight / 2;\n    root.y0 = 0;\n\n    // Layout the tree initially and center on the root node.\n    update(root);\n    centerNode(root);\n//});\n\n</script>"
    bodyBottom <- "</body>\n</html>"
    cat(
    	CSSHeadTop,
    	bgCSS,
    	textCSS,
    	linkCSS,
    	CSSHeadBottom,
    	scripts,
    	heads,
    	bodyTop,
    	treeData,
    	js1,
    	js2_1,
    	js2_2,
    	js2_3,
    	js2_4,
    	js2_5,
    	bodyBottom, 
    	file = outputFileName)
    browseURL(outputFileName)
}
    
